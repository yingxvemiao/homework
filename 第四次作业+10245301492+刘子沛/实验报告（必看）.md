## 实验四：数据库与SQL语句

在实验三中，我已经爬取了ESI网站的学科数据并完成1-2题

在实验四中，我决定还是用学长提供的数据来完成3-7题

#### 3. 将获取的数据导入到一个关系型数据库系统中（系统可以自选）

暑假我们刚学过SQL，那选择 SQL Server Management Studio 最顺手

先打开一个csv看一下，发现第1行是说明文字，第2行才是表头：

![](.\pictures\1.png)

最后一行是 Copyright ?2025 Clarivate，也应该去掉：

![](.\pictures\3.png)

SSMS 不能直接跳过第一行和最后一行，所以我们先把每个 CSV 的**第一行和最后一行删掉**，再导入

在 Powershell 执行下面命令：

```powershell
$src="D:\ESI\download"; $dst="D:\ESI\clean"; New-Item -ItemType Directory -Force -Path $dst | Out-Null
Get-ChildItem $src -Filter *.csv | ForEach-Object {
  $lines = Get-Content $_.FullNameGet-ChildItem $src -Filter *.csv
  $lines[1..($lines.Count-2)] | Set-Content -Encoding UTF8 (Join-Path $dst $_.Name)
}
```

解释一下：

1. src 是原始文件路径，dst 是目标文件路径
2. New-Item 用于创建一个新目录，如果 D:\ESI\clean 不存在，会自动创建
3. Get-ChildItem $src -Filter *.csv 会列出 src 中所有扩展名为 .csv 的文件
4. ForEach-Object 遍历每个文件
5. \$lines = Get-Content $_.FullName 会把整个文件的内容读成一个字符串数组，每一行是一个元素
6. \$lines[1..($lines.Count-2)] 是数组切片语法，表示从第二行到倒数第二行，删除文件的第一行和最后一行
7. Set-Content 把上一步得到的“去掉第一行的内容”写入到新的文件中

可以看到，第一行已经成功去掉了：

![](.\pictures\2.png)

最后一行也成功去掉了：

![](.\pictures\4.png)

批量导入所有CSV文件，每个表格的名字来源于CSV文件名，也就是**学科名称**：

```powershell
# === 参数设置 ===
$folder = "D:\ESI\clean"      # 存放 CSV 文件的文件夹
$server = "localhost"         # SQL Server 实例名
$database = "ESI"             # 目标数据库名

# === 遍历文件夹中所有 CSV 文件并逐个导入 ===
Get-ChildItem $folder -Filter *.csv | ForEach-Object {

    $file = $_.FullName                                     # 当前 CSV 文件的完整路径
    $table = "staging_" + ($_.BaseName -replace '[^A-Za-z0-9_]', '_')  # 根据文件名生成表名
    $tmp = [IO.Path]::GetTempFileName()                     # 创建一个临时 SQL 文件

@"
-- 如果表不存在就创建
IF OBJECT_ID('dbo.$table') IS NULL
BEGIN
  CREATE TABLE dbo.$table(
    [Rank] NVARCHAR(64),
    [Institutions] NVARCHAR(512),
    [Countries/Regions] NVARCHAR(128),
    [Web of Science Documents] NVARCHAR(64),
    [Cites] NVARCHAR(64),
    [Cites/Paper] NVARCHAR(64),
    [Top Papers] NVARCHAR(64)
  );
END;

-- 清空旧数据
TRUNCATE TABLE dbo.$table;

-- 从 CSV 导入数据
BULK INSERT dbo.$table
FROM '$file'
WITH (
  FORMAT='CSV',           -- 使用原生 CSV 解析
  FIRSTROW=2,             -- 第 1 行是表头，从第 2 行开始导
  FIELDQUOTE='"',         -- 支持带引号的字段
  ROWTERMINATOR='0x0d0a', -- Windows 换行符
  CODEPAGE='65001',       -- UTF-8 编码
  TABLOCK                 -- 提升导入性能
);

-- 显示导入结果
SELECT '$table' AS TableName, COUNT(*) AS RowsLoaded FROM dbo.$table;
GO
"@ | Set-Content -Encoding UTF8 $tmp   # 将 SQL 写入临时文件

    # 执行临时 SQL 文件
    sqlcmd -S $server -d $database -E -i $tmp

    # 删除临时文件，保持干净
    Remove-Item $tmp
}
```

所有表格已成功导入 SSMS：

![](.\pictures\5.png)

#### 4. 优化关系型数据，并整理一个合理的schema

为什么要优化？

​	为了**方便查询**，优化做的好，5-7题会非常简单

怎么优化？

​	目前是一个学科一个表格，我们要创建一个**总表**，整合所有数据

​	这个总表要增加一列，记录这行数据来源于哪个学科的排名表格：

```sql
USE ESI;
GO
-- 创建一个统一的总表，用来整合所有 staging_* 数据
IF OBJECT_ID('dbo.esi_rankings') IS NOT NULL DROP TABLE dbo.esi_rankings;
CREATE TABLE dbo.esi_rankings(
    id INT IDENTITY(1,1) PRIMARY KEY,        -- 自增主键
    discipline NVARCHAR(128) NOT NULL,       -- 学科名（来自表名）
    [rank] INT NULL,                         -- 排名
    institution NVARCHAR(255) NULL,          -- 机构名
    country_region NVARCHAR(128) NULL,       -- 国家或地区
    docs INT NULL,                           -- 论文数
    cites INT NULL,                          -- 引用数
    cites_per_paper DECIMAL(10,2) NULL,      -- 每篇引用数
    top_papers INT NULL                      -- 高被引论文数
);
GO
```

然后我们要遍历每个表格，从表名提取学科名，再把学科名结合其他信息，插入总表中：

```sql
-- 遍历所有 staging_* 表，将数据导入 esi_rankings
DECLARE @t SYSNAME, @sql NVARCHAR(MAX), @disc NVARCHAR(128);

-- 获取所有 staging_* 表名
DECLARE cur CURSOR LOCAL FAST_FORWARD FOR
SELECT name FROM sys.tables WHERE name LIKE 'staging\_%' ESCAPE '\';

OPEN cur; FETCH NEXT FROM cur INTO @t;
WHILE @@FETCH_STATUS = 0
BEGIN
    -- 从表名提取学科名，例如 staging_PHYSICS → "PHYSICS"
    SET @disc = REPLACE(SUBSTRING(@t, LEN('staging_')+1, 200), '_', ' ');

    -- 构造动态 SQL 插入语句
    SET @sql = '
      INSERT INTO dbo.esi_rankings(discipline,[rank],institution,country_region,docs,cites,cites_per_paper,top_papers)
      SELECT ''' + @disc + ''',
             TRY_CONVERT(INT,[Rank]),
             [Institutions],
             [Countries/Regions],
             TRY_CONVERT(INT,[Web of Science Documents]),
             TRY_CONVERT(INT,[Cites]),
             TRY_CONVERT(DECIMAL(10,2),[Cites/Paper]),
             TRY_CONVERT(INT,[Top Papers])
      FROM dbo.' + QUOTENAME(@t) + '
      WHERE [Institutions] IS NOT NULL AND [Institutions] NOT LIKE ''Copyright%'';
    ';
    EXEC(@sql);

    FETCH NEXT FROM cur INTO @t;
END
CLOSE cur; DEALLOCATE cur;
GO
```

为了方便后续查询，添加学科和机构索引：

```sql
-- 为后续查询（第5–7题）建立索引
CREATE INDEX IX_esi_rank_disc ON dbo.esi_rankings(discipline);   -- 按学科快速筛选
CREATE INDEX IX_esi_rank_inst ON dbo.esi_rankings(institution);  -- 按机构快速查询
GO
```

最终的总表如下：

![](.\pictures\6.png)

#### 5. 通过写SQL语句，获取华东师范大学在各个学科中的排名

注意，华东师范大学在表格中是英文名称，即 EAST CHINA NORMAL UNIVERSITY

从 dbo.esi_rankings 表格中，选择机构名为 EAST CHINA NORMAL UNIVERSITY 的行，按 rank 从小到大展示

```sql
USE ESI;
GO

-- 查询华东师范大学在各学科的ESI排名及相关指标
SELECT
    discipline,              -- 学科名
    [rank],                  -- 排名
    docs,                    -- 论文数
    cites,                   -- 引用数
    cites_per_paper,         -- 每篇论文引用数
    top_papers               -- 高被引论文数
FROM dbo.esi_rankings
WHERE institution LIKE N'%EAST CHINA NORMAL UNIVERSITY%'    -- 模糊匹配机构名
ORDER BY [rank];                            -- 按排名升序排列（数值小代表排名靠前）
```

运行结果如下：

![](.\pictures\7.png)

为了便于老师检查，我想把查询结果输出到一个文件中

把SQL代码保存为 SQLQuery5.sql，然后在 PowerShell 中运行：

```powershell
sqlcmd -S localhost -d ESI -E -i "D:\ESI\SQLQuery5.sql" -o "D:\ESI\result5.csv" -s "," -W -f 65001
```

文件在附件中供老师检查（5-7题都有，为了节省篇幅，后面不再说明）：

![](.\pictures\8.png)

#### 6. 通过写SQL语句，获取中国（大陆地区）大学在各个学科中的表现

如何限定范围（中国大陆）？

​	限定 country_region 为 CHINA MAINLAND 即可

如何衡量在各个学科中的表现？

​	看各学科上榜机构数量、平均排名、各学科被引论文总数、各学科论文总数、各学科引用总数、平均每篇引用

​	这些指标中，平均排名是最权威的，所有按平均排名升序展示

```sql
USE ESI;
GO

-- 第6题：分析中国大陆高校在各学科的表现
SELECT
    discipline,                        -- 学科
    COUNT(*) AS institution_count,     -- 上榜机构数量
    AVG([rank]) AS avg_rank,           -- 平均排名
    SUM(top_papers) AS total_top_papers, -- 各学科高被引论文总数
    SUM(docs) AS total_docs,           -- 各学科论文总数
    SUM(cites) AS total_cites,         -- 各学科引用总数
    ROUND(SUM(cites) * 1.0 / NULLIF(SUM(docs), 0), 2) AS avg_cites_per_paper -- 平均每篇引用
FROM dbo.esi_rankings
WHERE country_region LIKE N'%CHINA MAINLAND%'  -- 限定中国大陆高校
GROUP BY discipline
ORDER BY avg_rank;                             -- 按平均排名升序排列
```

运行结果如下：

![](.\pictures\9.png)

为了便于老师检查，我想把查询结果输出到一个文件中

把SQL代码保存为 SQLQuery6.sql，然后在 PowerShell 中运行：

```powershell
sqlcmd -S localhost -d ESI -E -i "D:\ESI\SQLQuery6.sql" -o "D:\ESI\result6.csv" -s "," -W -f 65001
```

#### 7. 通过写SQL语句，分析全球不同区域在各个学科中的表现

全球不同区域需要我们手动划分，按国家或地区填充所属大洲

```sql
-- 给表添加 region_group 字段
ALTER TABLE dbo.esi_rankings ADD region_group NVARCHAR(64);
GO

-- 按国家或地区填充所属大洲
UPDATE dbo.esi_rankings SET region_group = 'Asia'
WHERE country_region LIKE N'%CHINA%' OR country_region LIKE N'%JAPAN%' OR country_region LIKE N'%KOREA%' OR country_region LIKE N'%INDIA%';

UPDATE dbo.esi_rankings SET region_group = 'Europe'
WHERE country_region IN (N'UNITED KINGDOM', N'FRANCE', N'GERMANY', N'ITALY', N'SPAIN', N'NETHERLANDS');

UPDATE dbo.esi_rankings SET region_group = 'North America'
WHERE country_region IN (N'USA', N'CANADA', N'MEXICO');

UPDATE dbo.esi_rankings SET region_group = 'South America'
WHERE country_region IN (N'BRAZIL', N'ARGENTINA', N'CHILE');

UPDATE dbo.esi_rankings SET region_group = 'Oceania'
WHERE country_region IN (N'AUSTRALIA', N'NEW ZEALAND');

UPDATE dbo.esi_rankings SET region_group = 'Africa'
WHERE country_region IN (N'EGYPT', N'SOUTH AFRICA');
GO
```

这样，表格右侧就会增加一列 region_group，便于区分全球不同区域：

![](.\pictures\10.png)

之后的思路和第6题很相似，只不过 GROUP BY discipline 变为 GROUP BY region_group, discipline，从而将每个区域都展示一遍：

```sql
USE ESI;
GO

-- 第7题：分析全球不同区域在各学科的表现
SELECT
    region_group,                     -- 区域（亚洲、欧洲、北美等）
    discipline,                       -- 学科
    COUNT(*) AS institution_count,    -- 上榜机构数
    AVG([rank]) AS avg_rank,          -- 平均排名
    SUM(top_papers) AS total_top_papers,  -- 高被引论文总数
    SUM(docs) AS total_docs,          -- 论文总数
    SUM(cites) AS total_cites,        -- 引用总数
    ROUND(SUM(cites)*1.0/NULLIF(SUM(docs),0),2) AS avg_cites_per_paper  -- 平均每篇引用
FROM dbo.esi_rankings
WHERE region_group IS NOT NULL
GROUP BY region_group, discipline
ORDER BY region_group, avg_rank;
```

运行结果如下：

![](.\pictures\11.png)

为了便于老师检查，我想把查询结果输出到一个文件中

把SQL代码保存为 SQLQuery7.sql，然后在 PowerShell 中运行：

```powershell

sqlcmd -S localhost -d ESI -E -i "D:\ESI\SQLQuery7.sql" -o "D:\ESI\result7.csv" -s "," -W -f 65001
